#+OPTIONS: toc:4 num:nil

* fp
  - [[#macros][Macros]]
    - [[#fp--pipe-rest-functions][fp--pipe (&rest functions)]]
    - [[#fp--compose-rest-functions][fp--compose (&rest functions)]]
    - [[#fp--partial-fn-rest-args][fp--partial (fn &rest args)]]
    - [[#fp--rpartial-fn-rest-args][fp--rpartial (fn &rest args)]]
    - [[#fp--and-rest-functions][fp--and (&rest functions)]]
    - [[#fp--or-rest-functions][fp--or (&rest functions)]]
    - [[#fp--converge-combine-fn-rest-functions][fp--converge (combine-fn &rest functions)]]
    - [[#fp--when-pred-fn][fp--when (pred fn)]]
    - [[#fp--unless-pred-fn][fp--unless (pred fn)]]
  - [[#functions][Functions]]
    - [[#fp-pipe-rest-functions][fp-pipe (&rest functions)]]
    - [[#fp-compose-rest-functions][fp-compose (&rest functions)]]
    - [[#fp-partial-fn-rest-args][fp-partial (fn &rest args)]]
    - [[#fp-rpartial-fn-rest-args][fp-rpartial (fn &rest args)]]

** Macros
#+PROPERTY: header-args :results code
*** fp--pipe (&rest functions)

Return left-to-right composition from FUNCTIONS.

*Example:*
#+begin_src emacs-lisp :results raw :results code
(funcall (fp--pipe upcase split-string) "some string")
#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp--compose (&rest functions)

Return right-to-left composition from FUNCTIONS.

*Example:*
#+begin_src emacs-lisp
(funcall (fp--compose split-string upcase) "some string")
#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp--partial (fn &rest args)
Return a partial application of FN to left-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FN, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp--partial > 3) 2)
#+end_src

*Result:*
#+begin_src elisp
t
#+end_src

*** fp--rpartial (fn &rest args)
Return a partial application of FN to right-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FN, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp--rpartial > 3) 2)
#+end_src

*Result:*
#+begin_src elisp
nil
#+end_src

*Example:*
#+begin_src elisp
(funcall (fp--rpartial plist-get :name) '(:name "John" :age 30))
#+end_src

*Result:*
#+begin_src elisp
"John"
#+end_src

*** fp--and (&rest functions)
Return an unary function which call invoke FUNCTIONS until one of them yields nil.

*Example:*
#+begin_src elisp
(funcall (fp--and numberp 1+) 30)
#+end_src

*Result:*
#+begin_src elisp
31
#+end_src

*** fp--or (&rest functions)
Return a function that FUNCTIONS until one of them yields non-nil.

*Example:*
#+begin_src elisp
(seq-filter
 (fp--or numberp stringp)
 '("a" "b" (0 1 2 3 4) "c" 34 (:name "John" :age 30)))
#+end_src

*Result:*
#+begin_src elisp
("a" "b" "c" 34)
#+end_src

*** fp--converge (combine-fn &rest functions)

Return a new function that accepts a converging function COMBINE-FN and a list of branching FUNCTIONS.

When invoked, this new function is applied to some arguments, and each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value.

If first element of FUNCTIONS is a vector, it will be used instead.

For example here both ~upcase~ and ~downcase~ applied with argument John, and ~concat~ applied with results.

*Example:*
#+begin_src emacs-lisp
(funcall (fp--converge concat [upcase downcase]) "John")
#+end_src

*Result:*
#+begin_src emacs-lisp
"JOHNjohn"
#+end_src

*Example:*
#+begin_src emacs-lisp :results code
(funcall (fp--converge concat upcase downcase) "John")
#+end_src

*Result:*
#+begin_src emacs-lisp
"JOHNjohn"
#+end_src

*** fp--when (pred fn)
Return an unary function that invoke FN if result of calling PRED is non-nil.

If result of PRED is nil, return the argument as is.

Both PRED and FN called with one argument.

#+begin_src emacs-lisp
(defun truncate-maybe (str len)
  "Truncate STR if longer LEN, otherwise return STR."
  (funcall (fp--when
            (fp--compose (fp--partial < len) length)
            (fp--rpartial substring 0 len))
           str))

(list (truncate-maybe "long string" 4)
      (truncate-maybe "lo" 4))
#+end_src

*Result:*
#+begin_src emacs-lisp
("long" "lo")
#+end_src

*** fp--unless (pred fn)
Return an unary function that invoke FN if result of calling PRED is non-nil.

If result of PRED is nil, return the argument as is.

Both PRED and FN called with one argument.

#+begin_src emacs-lisp
(defun divide-maybe (a b)
  "Divide A and B unless B is 0."
  (funcall (fp--unless zerop
                       (fp--partial / a))
           b))

(list (divide-maybe 10 0)
      (divide-maybe 10 2))
#+end_src

*Result*:
#+begin_src emacs-lisp
(0 5)
#+end_src


** Functions
#+PROPERTY: header-args :results code
*** fp-pipe (&rest functions)
Return left-to-right composition from FUNCTIONS.

*Example:*
#+begin_src emacs-lisp
(funcall (fp-pipe #'upcase #'split-string) "some string")
#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp-compose (&rest functions)
Return right-to-left composition from FUNCTIONS.

*Example:*
#+begin_src emacs-lisp
(funcall (fp-compose #'split-string #'upcase) "some string")

#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp-partial (fn &rest args)
Return a partial application of FN to left-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FN, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-partial #'> 3) 2)
#+end_src

*Result:*
#+begin_src elisp
t
#+end_src

*** fp-rpartial (fn &rest args)
Return a partial application of FN to right-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FN, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-rpartial #'> 3) 2)
#+end_src

*Result:*
#+begin_src elisp
nil
#+end_src
