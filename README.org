#+OPTIONS: toc:4 num:nil


* fp
  - [[#requirements][Requirements]]
  - [[#installation][Installation]]
    - [[#manually][Manually]]
    - [[#with-use-package-and-straight][With use-package and straight]]
  - [[#usage][Usage]]
    - [[#fp-pipe-rest-functions][fp-pipe (&rest functions)]]
    - [[#fp-compose-rest-functions][fp-compose (&rest functions)]]
    - [[#fp-partial-fn-rest-args][fp-partial (fn &rest args)]]
    - [[#fp-rpartial-fn-rest-args][fp-rpartial (fn &rest args)]]
    - [[#fp-and-rest-functions][fp-and (&rest functions)]]
    - [[#fp-or-rest-functions][fp-or (&rest functions)]]
    - [[#fp-converge-combine-fn-rest-functions][fp-converge (combine-fn &rest functions)]]
    - [[#fp-use-with-combine-fn-rest-functions][fp-use-with (combine-fn &rest functions)]]
    - [[#fp-when-pred-fn][fp-when (pred fn)]]
    - [[#fp-unless-pred-fn][fp-unless (pred fn)]]
    - [[#fp-const-value][fp-const (value)]]
    - [[#fp-ignore-args-fn][fp-ignore-args (fn)]]

** Requirements

+ Emacs >= 25.1

** Installation

*** Manually

Download repository and it to your load path in your init file:

#+begin_src elisp :eval no

(add-to-list 'load-path "/path/to/fp)

(require 'fp)

#+end_src

*** With use-package and straight

#+begin_src elisp :eval no

(use-package fp
	:straight (fp
			       :repo "KarimAziev/fp"
			       :type git
			       :host github))

#+end_src
** Usage
*** fp-pipe (&rest functions)

Return left-to-right composition from ~functions~.

*Example:*
#+begin_src emacs-lisp :results raw :results code
(funcall (fp-pipe upcase split-string) "some string")
#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp-compose (&rest functions)

Return right-to-left composition from ~functions~.

*Example:*
#+begin_src emacs-lisp
(funcall (fp-compose split-string upcase) "some string")
#+end_src

*Result:*
#+begin_src emacs-lisp
("SOME" "STRING")
#+end_src

*** fp-partial (fn &rest args)
Return a partial application of =fn= to left-hand ~args~.

~args~ is a list of the last N arguments to pass to =fn=. The result is a new
function which does the same as =fn=, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-partial > 3) 2)
#+end_src

*Result:*
#+begin_src elisp
t
#+end_src

*** fp-rpartial (fn &rest args)

Return a partial application of =fn= to right-hand ~args~.

~args~ is a list of the last N arguments to pass to =fn=. The result is a new
function which does the same as =fn=, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-rpartial > 3) 2)
#+end_src

*Result:*
#+begin_src elisp
nil
#+end_src

*Example:*
#+begin_src elisp
(funcall (fp-rpartial plist-get :name) '(:name "John" :age 30))
#+end_src

*Result:*
#+begin_src elisp
"John"
#+end_src

*** fp-and (&rest functions)
Return an unary function which call invoke ~functions~ until one of them yields nil.

*Example:*
#+begin_src elisp
(funcall (fp-and numberp 1+) 30)
#+end_src

*Result:*
#+begin_src elisp
31
#+end_src

*** fp-or (&rest functions)
Return a function that ~functions~ until one of them yields non-nil.

*Example:*
#+begin_src elisp
(seq-filter
 (fp-or numberp stringp)
 '("a" "b" (0 1 2 3 4) "c" 34 (:name "John" :age 30)))
#+end_src

*Result:*
#+begin_src elisp
("a" "b" "c" 34)
#+end_src

*** fp-converge (combine-fn &rest functions)

Return a new function that accepts a converging function COMBINE-FN and a list of branching ~functions~.

When invoked, this new function is applied to some arguments, and each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value.

For example here both ~upcase~ and ~downcase~ applied with argument John, and ~concat~ applied with results.

*Example:*
#+begin_src emacs-lisp
(funcall (fp-converge concat [upcase downcase]) "John")
⇒ "JOHNjohn"
#+end_src

If first element of ~functions~ is a vector, it will be used instead.

*Example:*
#+begin_src emacs-lisp
(funcall (fp-converge concat upcase downcase) "John")
⇒ "JOHNjohn"
#+end_src


*** (fp-use-with combine-fn &rest functions)

  Return a function with the arity of length ~functions~.

  This function will apply ~combine-fn~ with results of every function called with *one* argument at the same index .

  *Example:*
  #+begin_src emacs-lisp

(funcall (fp-use-with concat [upcase downcase]) "hello " "world")
  ;;  ⇒ "HELLO world"
#+end_src

  If first element of ~functions~ is a vector, it will be used instead.

 #+begin_src emacs-lisp

(funcall (fp-use-with concat upcase downcase) "hello " "world")
;;   ⇒ "HELLO world"
#+end_src


*** fp-when (pred fn)
Return an unary function that invoke =fn= if result of calling PRED is non-nil.

If result of PRED is nil, return the argument as is.

Both PRED and =fn= called with one argument.

#+begin_src emacs-lisp
(defun truncate-maybe (str len)
  "Truncate STR if longer LEN, otherwise return STR."
  (funcall (fp-when
            (fp-compose (fp-partial < len) length)
            (fp-rpartial substring 0 len))
           str))

(list (truncate-maybe "long string" 4)
      (truncate-maybe "lo" 4))
#+end_src

*Result:*
#+begin_src emacs-lisp
("long" "lo")
#+end_src

*** fp-unless (pred fn)
Return an unary function that invoke =fn= if result of calling PRED is non-nil.

If result of PRED is nil, return the argument as is.

Both PRED and =fn= called with one argument.

#+begin_src emacs-lisp
(defun divide-maybe (a b)
  "Divide A and B unless B is 0."
  (funcall (fp-unless zerop
                       (fp-partial / a))
           b))

(list (divide-maybe 10 0)
      (divide-maybe 10 2))
#+end_src

*Result*:
#+begin_src emacs-lisp
(0 5)
#+end_src

*** fp-const (value)

Return a function that always return ~value.~

This function accepts any number of arguments, but ignores them.

#+begin_src emacs-lisp
(funcall (fp-const 2) 4)
#+end_src

*Result*:
#+begin_src emacs-lisp
2
#+end_src

*** fp-ignore-args (fn)

Return a function that invoke =fn= without args.

This function accepts any number of arguments, but ignores them.

#+begin_src emacs-lisp
(defun my-fn ()
  "Show message hello world."
  (message "Hello world"))

(funcall (fp-ignore-args my-fn) 4)
#+end_src

*Result*:
#+begin_src emacs-lisp
"Hello world"
#+end_src
