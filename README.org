
* fp
=fp= is a collection of combinators to write in point-free style (also called Tacit programming).

* Table of Contents                                          :TOC_4:QUOTE:
#+BEGIN_QUOTE
- [[#fp][fp]]
  - [[#requirements][Requirements]]
  - [[#installation][Installation]]
    - [[#manually][Manually]]
    - [[#with-use-package-and-straight][With use-package and straight]]
  - [[#usage][Usage]]
    - [[#fp-pipe-rest-functions][fp-pipe (&rest functions)]]
    - [[#fp-compose-rest-functions][fp-compose (&rest functions)]]
    - [[#fp-partial-fn-rest-args][fp-partial (fn &rest args)]]
    - [[#fp-rpartial-fn-rest-args][fp-rpartial (fn &rest args)]]
    - [[#fp-and-rest-functions][fp-and (&rest functions)]]
    - [[#fp-or-rest-functions][fp-or (&rest functions)]]
    - [[#fp-converge-combine-fn-rest-functions][fp-converge (combine-fn &rest functions)]]
    - [[#fp-use-with-combine-fn-rest-functions][fp-use-with (combine-fn &rest functions)]]
    - [[#fp-when-pred-fn][fp-when (pred fn)]]
    - [[#fp-unless-pred-fn][fp-unless (pred fn)]]
    - [[#fp-const-value][fp-const (value)]]
    - [[#fp-ignore-args-fn][fp-ignore-args (fn)]]
    - [[#fp-not-fn][fp-not (fn)]]
    - [[#fp-cond--rest-functions][fp-cond  (&rest functions)]]
#+END_QUOTE

** Requirements

+ Emacs >= 26.1

** Installation

*** Manually

Download repository and it to your load path in your init file:
#+begin_src elisp :eval no
(add-to-list 'load-path "/path/to/fp)
(require 'fp)
#+end_src

*** With use-package and straight

#+begin_src elisp :eval no
(use-package fp :straight (:repo "KarimAziev/fp" :type git :host github))
#+end_src

** Usage
*** fp-pipe (&rest functions)

Return left-to-right composition from ~functions~.

*Example:*
#+begin_src elisp :results raw :results code
(funcall (fp-pipe upcase split-string) "some string")
⇒ ("SOME" "STRING")
#+end_src


*** fp-compose (&rest functions)

Return right-to-left composition from ~functions~.

*Example:*
#+begin_src elisp
(funcall (fp-compose split-string upcase) "some string")
⇒ ("SOME" "STRING")
#+end_src

*** fp-partial (fn &rest args)
Return a partial application of =fn= to left-hand ~args~.

~args~ is a list of the last N arguments to pass to =fn=. The result is a new
function which does the same as =fn=, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-partial > 3) 2) ;; ⇒ t
#+end_src


*** fp-rpartial (fn &rest args)

Return a partial application of =fn= to right-hand ~args~.

~args~ is a list of the last N arguments to pass to =fn=. The result is a new
function which does the same as =fn=, except that the last N arguments are fixed
at the values with which this function was called.

*Example:*
#+begin_src elisp
(funcall (fp-rpartial plist-get :name) '(:name "John" :age 30))
;; ⇒ "John"
#+end_src


*** fp-and (&rest functions)
Return an unary function which call ~functions~ until one of them yields nil.

*Example:*
#+begin_src elisp
(funcall (fp-and numberp 1+) 30) ;; ⇒ 31
#+end_src


*** fp-or (&rest functions)
Return a function that ~functions~ until one of them yields non-nil.

*Example:*
#+begin_src elisp
(seq-filter
 (fp-or numberp stringp)
 '("a" "b" (0 1 2 3 4) "c" 34 (:name "John" :age 30)))

;; ⇒ ("a" "b" "c" 34)
#+end_src


*** fp-converge (combine-fn &rest functions)

Return a new function that accepts a converging function COMBINE-FN and a list of branching ~functions~.

When invoked, this new function is applied to some arguments, and each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value.

For example here both ~upcase~ and ~downcase~ applied with argument John, and ~concat~ applied with results.

*Example:*
#+begin_src elisp
(funcall (fp-converge concat [upcase downcase]) "John")
;; ⇒ "JOHNjohn"
#+end_src

If first element of ~functions~ is a vector, it will be used instead.

*Example:*
#+begin_src elisp
(funcall (fp-converge concat upcase downcase) "John")
;; ⇒ "JOHNjohn"
#+end_src


*** fp-use-with (combine-fn &rest functions)

  Return a function with the arity of length ~functions~.
  This function will apply ~combine-fn~ with results of every function called with *one* argument at the same index .

  *Example:*
  #+begin_src elisp

(funcall (fp-use-with concat [upcase downcase]) "hello " "world")
  ;;  ⇒ "HELLO world"
#+end_src

  If first element of ~functions~ is a vector, it will be used instead.

 #+begin_src elisp

(funcall (fp-use-with concat upcase downcase) "hello " "world")
;;   ⇒ "HELLO world"
#+end_src


*** fp-when (pred fn)
Return an unary function that invoke =fn= if result of calling ~pred~ is non-nil.

If result of ~pred~ is nil, return the argument as is.

Both ~pred~ and =fn= called with one argument.

#+begin_src elisp
(defun truncate-maybe (str len)
  "Truncate STR if longer LEN, otherwise return STR."
  (funcall (fp-when
            (fp-compose (fp-partial < len) length)
            (fp-rpartial substring 0 len))
           str))

(list (truncate-maybe "long string" 4)
      (truncate-maybe "lo" 4))

;; ⇒ ("long" "lo")
#+end_src

*** fp-unless (pred fn)
Return an unary function that invoke =fn= if result of calling ~pred~ is non-nil.

If result of ~pred~ is nil, return the argument as is.

Both ~pred~ and =fn= called with one argument.

#+begin_src elisp
(defun divide-maybe (a b)
  "Divide A and B unless B is 0."
  (funcall (fp-unless zerop
                       (fp-partial / a))
           b))

(list (divide-maybe 10 0)
      (divide-maybe 10 2))

;; ⇒ '(0 5)
#+end_src

*** fp-const (value)

Return a function that always return ~value.~

This function accepts any number of arguments, but ignores them.

#+begin_src elisp
(funcall (fp-const 2) 4) ;; ⇒ 2
#+end_src


*** fp-ignore-args (fn)

Return a function that invoke =fn= without args.

This function accepts any number of arguments, but ignores them.

#+begin_src elisp
(defun my-fn ()
  "Show message hello world."
  (message "Hello world"))

(funcall (fp-ignore-args my-fn) 4) ;;   ⇒ "Hello world"
#+end_src

*** fp-not (fn)

Return a function that negates the result of a function ~fn~.

#+begin_src elisp

(funcall (fp-not stringp) 4) ;;   ⇒ t
#+end_src

*** fp-cond  (&rest functions)
Return a function that apply ~functions~ as cond clauses. Functions should be a vector of [predicate transformer] pairs or a list (predicate transformer).

#+begin_src emacs-lisp
(funcall (fp-cond
          [stringp upcase]
          [symbolp symbol-name]
          [numberp (fp-partial * 2)])
         2)

;;   ⇒ 4
#+end_src

